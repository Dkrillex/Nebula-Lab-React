# Router 路由文档

本目录包含应用的路由配置和路由守卫逻辑。

## 文件结构

```
router/
├── index.tsx          # 路由主入口，创建路由实例
├── AuthGuard.tsx      # 路由认证守卫
├── context.ts         # 路由上下文定义（KeepAlive 兼容）
└── routes/
    ├── core.tsx       # 核心路由配置（Layout、Home、Privacy）
    └── local.tsx      # 本地业务路由配置（Dashboard相关页面）
```

## 文件说明

### **index.tsx** - 路由主入口
- **功能**: 创建并导出 React Router 的路由实例
- **特性**:
  - 使用 `createHashRouter` 创建路由（Hash 模式）
  - 自动处理路由懒加载（Suspense）
  - 自动应用 AuthGuard（根据 meta.requiresAuth）
  - **KeepAlive 集成**: 自动识别 `meta.keepAlive` 并包裹 `KeepAliveBoundary`
  - 自动生成唯一缓存 Key (基于全路径或 `meta.keepAliveKey`)

### **AuthGuard.tsx** - 路由认证守卫
- **功能**: 保护需要认证的路由
- **扩展类型**:
  - `RouteMeta` 增加了 `keepAlive` (boolean) 和 `keepAliveKey` (string) 属性

### **routes/local.tsx** - 业务路由
- **KeepAlive 支持**: 大部分页面已启用缓存，通过 `RouteWrapper` 统一管理。

## KeepAlive 缓存机制 (核心)

系统集成了 `react-activation` 实现类似 Vue 的 `keep-alive` 功能，并进行了深度定制以适配 React Router Outlet 模型。

### 1. 启用缓存
在路由配置的 `meta` 中设置 `keepAlive: true`。可选设置 `keepAliveKey` 指定特定缓存名（默认使用完整路由路径）。

```typescript
{
  path: 'example',
  element: <ExamplePage />,
  meta: {
    title: 'Example',
    keepAlive: true, // 开启缓存
    keepAliveKey: '/my-custom-key' // (可选) 显式指定缓存 Key
  }
}
```

### 2. 架构原理
- **AliveScope**: 位于 `Layout.tsx` 顶层，作为缓存容器。
- **KeepAliveBoundary**: 位于 `components/KeepAlive.tsx`，负责包裹具体页面组件。
  - 自动桥接 `Outlet` Context (`AppContext`)，确保缓存组件能获取翻译和导航方法。
  - 监听页面刷新 (`reload`)，若检测到刷新则自动清理对应缓存，防止旧状态残留。

### 3. 缓存生命周期管理
- **生成 Key**: `router/index.tsx` 会递归生成路由的全路径（如 `/create/textToImage`）作为默认缓存 Key。
- **清理缓存**: `components/Layout.tsx` 在关闭标签页 (Tab) 时，通过 `useAliveController().drop(key)` 主动移除缓存。
- **刷新策略**: 页面刷新时，`KeepAliveBoundary` 会检测 `performance.navigation`，如果是 reload 操作，会强制丢弃当前页面的缓存。

### 4. 页面组件开发规范
为了确保在 KeepAlive 模式下正常工作：
1. **使用 `RouteWrapper`**: 推荐使用通用的 `RouteWrapper` 包裹页面组件。
2. **使用 `useAppOutletContext`**: 替代 `useOutletContext` 以获取 Context。
3. **副作用处理**: 使用 `useActivate` / `useUnactivate` (来自 `react-activation`) 处理激活/冻结逻辑。

## 使用方式

### 在组件中获取路由上下文
```typescript
import { useAppOutletContext } from '../../router/context';

function MyComponent() {
  const { t, handleNavClick } = useAppOutletContext();
  // ...
}
```
