# Router 路由文档

本目录包含应用的路由配置和路由守卫逻辑。

## 文件结构

```
router/
├── index.tsx          # 路由主入口，创建路由实例
├── AuthGuard.tsx      # 路由认证守卫
├── context.ts         # 路由上下文定义（KeepAlive 兼容）
└── routes/
    ├── core.tsx       # 核心路由配置（Layout、Home、Privacy）
    └── local.tsx      # 本地业务路由配置（Dashboard相关页面）
```

## 文件说明

### **index.tsx** - 路由主入口
- **功能**: 创建并导出 React Router 的路由实例
- **特性**:
  - 使用 `createHashRouter` 创建路由（Hash 模式）
  - 自动处理路由懒加载（Suspense）
  - 自动应用 AuthGuard（根据 meta.requiresAuth）
  - **KeepAlive 集成**: 自动识别 `meta.keepAlive` 并包裹 `KeepAliveWrapper`
  - 合并 coreRoutes 和 localRoutes

### **AuthGuard.tsx** - 路由认证守卫
- **功能**: 保护需要认证的路由
- **特性**:
  - 检查用户 Token 和认证状态
  - 支持路由白名单（不需要登录的路由）
  - 白名单路由：
    - `/`
    - `/auth/login`
    - `/auth/register`
    - `/privacy`
  - 可配置的认证要求（通过 meta.requiresAuth）

### **routes/core.tsx** - 核心路由
- **功能**: 定义应用的核心路由结构
- **路由配置**:
  - `/` (Layout 组件)
    - `/` (index): Home 页面 - 首页
    - `/privacy`: Privacy 页面 - 隐私政策页
  - `*`: 404 重定向到首页

### **routes/local.tsx** - 业务路由
- **功能**: 定义业务功能相关的路由
- **配置**: DashboardLayout 下的各个子页面（Create, Assets, Chat 等）
- **特点**:
  - 需认证
  - 懒加载
  - **KeepAlive 支持**: 大部分页面已启用缓存

## 路由结构

```
/ (Layout)
├── / (Home) - 首页
├── /privacy - 隐私政策
└── DashboardLayout
    ├── /create - 创作中心 (KeepAlive)
    ├── /assets - 素材管理 (KeepAlive)
    ├── /chat - AI 对话 (KeepAlive)
    ├── /keys - API 密钥 (KeepAlive)
    ├── /models - 模型广场 (KeepAlive)
    ├── /expenses - 消费记录 (KeepAlive)
    ├── /pricing - 价格方案 (KeepAlive)
    └── /profile - 个人中心 (KeepAlive)
```

## KeepAlive 缓存机制 (核心)

系统集成了 `react-activation` 实现类似 Vue 的 `keep-alive` 功能，并解决了 Context 丢失问题。

### 1. 启用缓存
在路由配置的 `meta` 中设置 `keepAlive: true`。

```typescript
{
  path: 'example',
  element: <ExamplePage />,
  meta: {
    title: 'Example',
    keepAlive: true // 开启缓存
  }
}
```

### 2. 实现原理
`router/index.tsx` 中的 `processRoutes` 函数会自动处理：
1. **Suspense 包裹**: 最外层包裹 `Suspense`，确保懒加载时显示 Loading。
2. **KeepAliveWrapper**: 在 `Suspense` 内部包裹 `KeepAliveWrapper`。
   - **结构**: `Suspense` -> `KeepAliveWrapper` -> `Component`
   - **优势**: 避免 KeepAlive 缓存 Suspense 的 fallback 状态；组件加载完成后才进入缓存。

### 3. Context 桥接
`KeepAlive` 使用 Portal 将组件渲染到 `AliveScope`（通常在 App 根节点），这会导致组件脱离原有的 React 组件树，从而丢失 `Outlet` 提供的 Context（如 `t` 翻译函数）。

**解决方案**:
- **KeepAliveWrapper (`components/KeepAlive.tsx`)**:
  - 获取当前的 `useOutletContext`。
  - 在 `KeepAlive` 内部重新提供一个 `AppContext.Provider`。
- **useAppOutletContext (`router/context.ts`)**:
  - 页面组件应使用此 Hook 替代 `useOutletContext`。
  - 它会优先读取 `AppContext` (KeepAlive 提供的)，如果为空则读取 `useOutletContext` (常规路由提供的)。
  - 包含安全降级处理，防止 Context 为 null 时页面崩溃。

### 4. 页面组件开发规范
为了确保在 KeepAlive 模式下正常工作：
1. **使用 `RouteWrapper`**: 推荐使用通用的 `RouteWrapper` 包裹页面组件，它负责处理 Context 映射和默认翻译数据注入。
2. **使用 `useAppOutletContext`**: 不要直接使用 `useOutletContext`。
3. **Props 优先**: 组件应优先从 Props 接收 `t` (翻译) 等数据（由 Wrapper 注入），其次再尝试从 Context 获取。
4. **副作用清理**: 使用 `useActivate` 和 `useUnactivate` (来自 `react-activation`) 处理页面激活/冻结时的逻辑（如定时器、事件监听），而不是仅依赖 `useEffect`。

## 使用方式

### 在组件中获取路由上下文
```typescript
import { useAppOutletContext } from '../../router/context';

function MyComponent() {
  const { t, handleNavClick } = useAppOutletContext();
  // ...
}
```

### 添加新 KeepAlive 路由
推荐使用 `RouteWrapper`：

```typescript
// router/routes/local.tsx
import { RouteWrapper } from '../../components/RouteWrapper';
const MyPage = React.lazy(() => import('../../pages/MyPage'));

{
  path: 'my-page',
  element: <RouteWrapper component={MyPage} translationKey="myPage" />,
  meta: { title: 'My Page', keepAlive: true }
}
```
